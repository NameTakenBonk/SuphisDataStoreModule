"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[870],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),u=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(i.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=u(n),h=o,f=c["".concat(i,".").concat(h)]||c[h]||p[h]||r;return n?a.createElement(f,l(l({ref:t},d),{},{components:n})):a.createElement(f,l({ref:t},d))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=h;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[c]="string"==typeof e?e:o,l[1]=s;for(var u=2;u<r;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},53261:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(87462),o=(n(67294),n(3905));const r={sidebar_position:7},l="Queing",s={unversionedId:"queuing",id:"queuing",title:"Queing",description:"Queing is usefull because you can save data without opening the data store iteself.",source:"@site/docs/queuing.md",sourceDirName:".",slug:"/queuing",permalink:"/SuphisDataStoreModule/docs/queuing",draft:!1,editUrl:"https://github.com/NameTakenBonk/SuphisDataStoreModule/edit/master/docs/queuing.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"defaultSidebar",previous:{title:"Compression",permalink:"/SuphisDataStoreModule/docs/compression"}},i={},u=[{value:"Setup",id:"setup",level:2},{value:"Creating the Proccess Queue function",id:"creating-the-proccess-queue-function",level:2},{value:"Giving Coins",id:"giving-coins",level:2},{value:"Full Source Code:",id:"full-source-code",level:3},{value:"Example 1",id:"example-1",level:2},{value:"Example 2",id:"example-2",level:2}],d={toc:u},c="wrapper";function p(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"queing"},"Queing"),(0,o.kt)("p",null,"Queing is usefull because you can save data without opening the data store iteself."),(0,o.kt)("h2",{id:"setup"},"Setup"),(0,o.kt)("p",null,"Let's just get the basic things we need setup like we always do."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local ServerStorage = game:GetService("ServerStorage")\nlocal DataStoreModule = require(ServerStorage.DataStoreModule)\n\nlocal template = {\n    Level = 0,\n    Coins = 0,\n    Inventory = {},\n    DeveloperProducts = {},\n}\n\ngame.Players.ChildAdded:Connect(function(player)\n    local dataStore = DataStoreModule.new("Player", player.UserId)\n    if dataStore:Open(template) ~= "Success" then print(player.Name, "failed to open") return end\n    dataStore.ProcessQueue:Connect(ProcessQueue)\nend)\n\ngame.Players.ChildRemoved:Connect(function(player)\n    local dataStore = DataStoreModule.find("Player", player.UserId)\n    if dataStore ~= nil then dataStore:Destroy() end\nend)\n\ntask.wait(5)\nlocal success = GiveCoins("your user id", 10)\n')),(0,o.kt)("h2",{id:"creating-the-proccess-queue-function"},"Creating the Proccess Queue function"),(0,o.kt)("p",null,"Although there is a queue function built we will need to do a bit more"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local function ProcessQueue(id, values, dataStore)\n    if dataStore:Remove(id) ~= "Success" then return end\n    for index, value in values do dataStore.Value.Coins += value end\nend\n')),(0,o.kt)("p",null,"This function will only get called if the data store is open and needs to fufill the queue."),(0,o.kt)("h2",{id:"giving-coins"},"Giving Coins"),(0,o.kt)("p",null,"Now we will have to give the coins themself"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local function GiveCoins(userId, amount)\n    local dataStore = DataStoreModule.find("Player", userId) or DataStoreModule.hidden("Player", userId)\n    local response = dataStore:Open(template)\n\n    elseif response == "Locked" then\n        return dataStore:Queue(amount, 3888000) == "Success"\n    else\n        return false \n    end\n    return dataStore.Hidden == false or dataStore:Destroy() == "Saved" -- if this is a hidden datastore destroy it\nend\n')),(0,o.kt)("p",null,"We are going to find a data store or try to create a hidden one( More information on hidden on the next chapter )"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'    if response == "Success" then\n        dataStore.Value.Coins += amount \n')),(0,o.kt)("p",null,"Here we add the coins directly if the datastore is already open. But what if it's locked then we will need to queue the coins to do so we created an if statement to check if it is locked then queue the value. It will queue for 3888000 seconds or as it's equal to 45 days. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'    elseif response == "Locked" then\n        return dataStore:Queue(amount, 3888000) == "Success"\n')),(0,o.kt)("p",null,"If none of these work then the roblox servers are down."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"    else\n        return false -- roblox servers are down\n    end\n")),(0,o.kt)("p",null,"Finally if this was hidden datastore then we destroy it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'    return dataStore.Hidden == false or dataStore:Destroy() == "Saved" \n')),(0,o.kt)("h3",{id:"full-source-code"},"Full Source Code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local DataStoreModule = require(11671168253)\n\nlocal template = {\n    Level = 0,\n    Coins = 0,\n    Inventory = {},\n    DeveloperProducts = {},\n}\n\nlocal function ProcessQueue(id, values, dataStore)\n    -- this function will only get called if the datastore is open\n    if dataStore:Remove(id) ~= "Success" then return end\n    for index, value in values do dataStore.Value.Coins += value end\n    -- if the datastore fails to save after we changed the coins, coins will be lost\nend\n\nlocal function GiveCoins(userId, amount)\n    -- try to find a datastore or create a hidden one\n    local dataStore = DataStoreModule.find("Player", userId) or DataStoreModule.hidden("Player", userId)\n    local response = dataStore:Open(template)\n    if response == "Success" then\n        dataStore.Value.Coins += amount -- datastore is open set the coins directly\n    elseif response == "Locked" then\n        -- another server has the datastore open add the amount to the queue so they can process it\n        -- it\'s posible that the other server might miss the amount added to the queue\n        -- if so amount will stay in the queue for upto (3888000 seconds / 45 days)\n        return dataStore:Queue(amount, 3888000) == "Success"\n    else\n        return false -- roblox servers are down\n    end\n    return dataStore.Hidden == false or dataStore:Destroy() == "Saved" -- if this is a hidden datastore destroy it\nend\n\ngame.Players.ChildAdded:Connect(function(player)\n    local dataStore = DataStoreModule.new("Player", player.UserId)\n    if dataStore:Open(template) ~= "Success" then print(player.Name, "failed to open") return end\n    dataStore.ProcessQueue:Connect(ProcessQueue)\nend)\n\ngame.Players.ChildRemoved:Connect(function(player)\n    local dataStore = DataStoreModule.find("Player", player.UserId)\n    if dataStore ~= nil then dataStore:Destroy() end\nend)\n\n-- try to give 5uphi 10 coins after 5 seconds\ntask.wait(5)\nlocal success = GiveCoins("456056545", 10)\n')),(0,o.kt)("p",null,"Now this is good and all but we can make it even safer. There is actually two ways infact let me show:"),(0,o.kt)("h2",{id:"example-1"},"Example 1"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local function ProcessQueue(id, values, dataStore)\n    -- try to remove values from the queue if not success then return\n    if dataStore:Remove(id) ~= "Success" then return end\n\n    -- add coins for each value in the queue\n    for index, value in values do dataStore.Value.Coins += value end\n\n    -- try to save the datastore if saved then return\n    if dataStore:Save() == "Saved" then return end\n\n    -- try to adding the values back into the queue so we can process them again later\n    -- if we succeed in adding the value back into the queue remove the coins so they dont get saved in the next saving intervals\n    for index, value in values do\n        if dataStore:Queue(value, 3888000) == "Success" then dataStore.Value.Coins -= value end\n    end\n\n    -- any values that we could not add back into the queue will stay inside datastore.Value.Coins and hopefully they will get saved in the next saving intervals\n    -- if the next saving intervals also fail then the coins will be lost\nend\n')),(0,o.kt)("h2",{id:"example-2"},"Example 2"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'local function ProcessQueue(id, values, dataStore)\n    -- add coins for each value in the queue\n    for index, value in values do dataStore.Value.Coins += value end\n\n    -- try to save the datastore if not saved then remove coins and return\n    if dataStore:Save() ~= "Saved" then\n        for index, value in values do dataStore.Value.Coins -= value end\n        return\n    end\n\n    -- try to remove values from the queue if success then return\n    if dataStore:Remove(id) == "Success" then return end\n\n    -- because remove was not success remove coins\n    for index, value in values do dataStore.Value.Coins -= value end\n\n    -- try to save the datastore\n    dataStore:Save()\n\n    -- if the datastore fails to save hopefully it will get saved in the next saving intervals\n    -- if the next saving intervals also fail then when the queue gets processed again and they will get the coins again\nend\n')))}p.isMDXComponent=!0}}]);